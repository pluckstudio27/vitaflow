#!/usr/bin/env python3
"""
Sistema de DetecÃ§Ã£o e CorreÃ§Ã£o AutomÃ¡tica de Erros
Sistema Almox SMS

Este mÃ³dulo implementa um sistema inteligente para detectar e corrigir
automaticamente erros comuns na aplicaÃ§Ã£o.

Funcionalidades:
- AnÃ¡lise de logs de erro
- DetecÃ§Ã£o de padrÃµes de falha
- CorreÃ§Ãµes automÃ¡ticas baseadas em regras
- Backup automÃ¡tico antes das correÃ§Ãµes
- ValidaÃ§Ã£o pÃ³s-correÃ§Ã£o

Autor: Sistema Automatizado de CorreÃ§Ãµes
Data: 2024
"""

import os
import sys
import re
import json
import shutil
import subprocess
import traceback
from datetime import datetime
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from enum import Enum
import ast

class ErrorType(Enum):
    """Tipos de erro detectados"""
    IMPORT_ERROR = "import_error"
    SYNTAX_ERROR = "syntax_error"
    ATTRIBUTE_ERROR = "attribute_error"
    NAME_ERROR = "name_error"
    TYPE_ERROR = "type_error"
    VALUE_ERROR = "value_error"
    KEY_ERROR = "key_error"
    INDEX_ERROR = "index_error"
    DATABASE_ERROR = "database_error"
    API_ERROR = "api_error"
    TEMPLATE_ERROR = "template_error"
    CONFIGURATION_ERROR = "configuration_error"

@dataclass
class ErrorPattern:
    """PadrÃ£o de erro detectado"""
    error_type: ErrorType
    pattern: str
    file_path: Optional[str]
    line_number: Optional[int]
    description: str
    suggested_fix: str

@dataclass
class FixResult:
    """Resultado de uma correÃ§Ã£o"""
    success: bool
    error_pattern: ErrorPattern
    fix_applied: str
    backup_path: Optional[str]
    validation_passed: bool
    message: str

class AutoFixer:
    """Sistema de correÃ§Ã£o automÃ¡tica"""
    
    def __init__(self, project_root: str = None):
        self.project_root = project_root or os.path.dirname(os.path.abspath(__file__))
        self.backup_dir = os.path.join(self.project_root, "backups")
        self.fixes_applied = []
        self.error_patterns = self._load_error_patterns()
        
        # Criar diretÃ³rio de backup
        os.makedirs(self.backup_dir, exist_ok=True)
    
    def _load_error_patterns(self) -> List[ErrorPattern]:
        """Carrega padrÃµes de erro conhecidos"""
        patterns = [
            # Erros de importaÃ§Ã£o
            ErrorPattern(
                error_type=ErrorType.IMPORT_ERROR,
                pattern=r"ImportError: cannot import name '(\w+)' from '([^']+)'",
                file_path=None,
                line_number=None,
                description="Erro de importaÃ§Ã£o - nome nÃ£o encontrado",
                suggested_fix="Verificar se o nome existe no mÃ³dulo ou corrigir importaÃ§Ã£o"
            ),
            
            ErrorPattern(
                error_type=ErrorType.IMPORT_ERROR,
                pattern=r"ModuleNotFoundError: No module named '([^']+)'",
                file_path=None,
                line_number=None,
                description="MÃ³dulo nÃ£o encontrado",
                suggested_fix="Instalar mÃ³dulo ou corrigir caminho de importaÃ§Ã£o"
            ),
            
            # Erros de atributo
            ErrorPattern(
                error_type=ErrorType.ATTRIBUTE_ERROR,
                pattern=r"AttributeError: '(\w+)' object has no attribute '(\w+)'",
                file_path=None,
                line_number=None,
                description="Atributo nÃ£o existe no objeto",
                suggested_fix="Verificar se o atributo existe ou usar mÃ©todo alternativo"
            ),
            
            # Erros de banco de dados
            ErrorPattern(
                error_type=ErrorType.DATABASE_ERROR,
                pattern=r"sqlalchemy\.exc\.(\w+): (.+)",
                file_path=None,
                line_number=None,
                description="Erro do SQLAlchemy",
                suggested_fix="Verificar configuraÃ§Ã£o do banco de dados"
            ),
            
            # Erros de API
            ErrorPattern(
                error_type=ErrorType.API_ERROR,
                pattern=r"500 Internal Server Error",
                file_path=None,
                line_number=None,
                description="Erro interno do servidor",
                suggested_fix="Verificar logs do servidor e corrigir erro interno"
            ),
            
            # Erros especÃ­ficos do projeto
            ErrorPattern(
                error_type=ErrorType.ATTRIBUTE_ERROR,
                pattern=r"'CentralMongo' object has no attribute 'find_all'",
                file_path=None,
                line_number=None,
                description="MÃ©todo find_all nÃ£o existe em CentralMongo",
                suggested_fix="Substituir find_all() por find_many()"
            ),
            
            ErrorPattern(
                error_type=ErrorType.IMPORT_ERROR,
                pattern=r"cannot import name 'ScopeFilter' from 'auth'",
                file_path=None,
                line_number=None,
                description="ScopeFilter importado do mÃ³dulo errado",
                suggested_fix="Importar ScopeFilter do mÃ³dulo correto (auth_mongo)"
            ),
        ]
        
        return patterns
    
    def create_backup(self, file_path: str) -> str:
        """Cria backup de um arquivo antes da correÃ§Ã£o"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = os.path.basename(file_path)
            backup_filename = f"{filename}.backup_{timestamp}"
            backup_path = os.path.join(self.backup_dir, backup_filename)
            
            shutil.copy2(file_path, backup_path)
            return backup_path
            
        except Exception as e:
            print(f"Erro ao criar backup: {e}")
            return None
    
    def analyze_file_for_errors(self, file_path: str) -> List[ErrorPattern]:
        """Analisa um arquivo Python em busca de erros"""
        errors = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Verificar sintaxe
            try:
                ast.parse(content)
            except SyntaxError as e:
                errors.append(ErrorPattern(
                    error_type=ErrorType.SYNTAX_ERROR,
                    pattern=f"SyntaxError: {e.msg}",
                    file_path=file_path,
                    line_number=e.lineno,
                    description=f"Erro de sintaxe na linha {e.lineno}",
                    suggested_fix="Corrigir sintaxe Python"
                ))
            
            # Verificar padrÃµes especÃ­ficos
            lines = content.split('\n')
            for i, line in enumerate(lines, 1):
                # Verificar importaÃ§Ãµes problemÃ¡ticas
                if "from auth_mongo import ScopeFilter" in line:
                    errors.append(ErrorPattern(
                        error_type=ErrorType.IMPORT_ERROR,
                        pattern="from auth_mongo import ScopeFilter",
                        file_path=file_path,
                        line_number=i,
                        description="ImportaÃ§Ã£o incorreta do ScopeFilter",
                        suggested_fix="Mudar para 'from auth_mongo import ScopeFilter'"
                    ))
                
                # Verificar uso de mÃ©todos inexistentes
                if ".find_many()" in line and "Mongo" in line:
                    errors.append(ErrorPattern(
                        error_type=ErrorType.ATTRIBUTE_ERROR,
                        pattern=".find_many()",
                        file_path=file_path,
                        line_number=i,
                        description="MÃ©todo find_all() nÃ£o existe em modelos MongoDB",
                        suggested_fix="Substituir por .find_many()"
                    ))
                
                # Verificar uso de mÃ©todos SQLAlchemy em contexto MongoDB
                if "ScopeFilter.filter_centrais_mongo()" in line and "USE_MONGO" in content:
                    errors.append(ErrorPattern(
                        error_type=ErrorType.ATTRIBUTE_ERROR,
                        pattern="ScopeFilter.filter_centrais_mongo()",
                        file_path=file_path,
                        line_number=i,
                        description="MÃ©todo SQLAlchemy usado em contexto MongoDB",
                        suggested_fix="Usar ScopeFilter.filter_centrais_mongo()"
                    ))
        
        except Exception as e:
            print(f"Erro ao analisar arquivo {file_path}: {e}")
        
        return errors
    
    def fix_import_error(self, error: ErrorPattern) -> FixResult:
        """Corrige erros de importaÃ§Ã£o"""
        if not error.file_path:
            return FixResult(
                success=False,
                error_pattern=error,
                fix_applied="",
                backup_path=None,
                validation_passed=False,
                message="Caminho do arquivo nÃ£o especificado"
            )
        
        backup_path = self.create_backup(error.file_path)
        
        try:
            with open(error.file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            original_content = content
            
            # CorreÃ§Ãµes especÃ­ficas
            if "from auth_mongo import ScopeFilter" in content:
                content = content.replace(
                    "from auth_mongo import ScopeFilter",
                    "from auth_mongo import ScopeFilter"
                )
                fix_description = "Corrigida importaÃ§Ã£o do ScopeFilter"
            
            elif "from models.usuario import Usuario" in content and "USE_MONGO" in content:
                # Adicionar importaÃ§Ã£o condicional
                if "from models_mongo.usuario import UsuarioMongo" not in content:
                    import_section = content.find("from models.usuario import Usuario")
                    if import_section != -1:
                        new_import = "from models.usuario import Usuario\nfrom models_mongo.usuario import UsuarioMongo"
                        content = content.replace("from models.usuario import Usuario", new_import)
                        fix_description = "Adicionada importaÃ§Ã£o condicional para MongoDB"
            
            else:
                return FixResult(
                    success=False,
                    error_pattern=error,
                    fix_applied="",
                    backup_path=backup_path,
                    validation_passed=False,
                    message="CorreÃ§Ã£o nÃ£o implementada para este tipo de erro de importaÃ§Ã£o"
                )
            
            # Inicializar fix_description se nÃ£o foi definido
            if 'fix_description' not in locals():
                fix_description = "CorreÃ§Ã£o de importaÃ§Ã£o aplicada"
            
            # Salvar arquivo corrigido
            with open(error.file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Validar correÃ§Ã£o
            validation_passed = self.validate_fix(error.file_path)
            
            return FixResult(
                success=True,
                error_pattern=error,
                fix_applied=fix_description,
                backup_path=backup_path,
                validation_passed=validation_passed,
                message="CorreÃ§Ã£o aplicada com sucesso"
            )
            
        except Exception as e:
            return FixResult(
                success=False,
                error_pattern=error,
                fix_applied="",
                backup_path=backup_path,
                validation_passed=False,
                message=f"Erro ao aplicar correÃ§Ã£o: {e}"
            )
    
    def fix_attribute_error(self, error: ErrorPattern) -> FixResult:
        """Corrige erros de atributo"""
        if not error.file_path:
            return FixResult(
                success=False,
                error_pattern=error,
                fix_applied="",
                backup_path=None,
                validation_passed=False,
                message="Caminho do arquivo nÃ£o especificado"
            )
        
        backup_path = self.create_backup(error.file_path)
        
        try:
            with open(error.file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # CorreÃ§Ãµes especÃ­ficas
            if ".find_many()" in error.pattern:
                content = content.replace(".find_many()", ".find_many()")
                fix_description = "SubstituÃ­do find_all() por find_many()"
            
            elif "ScopeFilter.filter_centrais_mongo()" in error.pattern:
                content = content.replace(
                    "ScopeFilter.filter_centrais_mongo()",
                    "ScopeFilter.filter_centrais_mongo()"
                )
                fix_description = "SubstituÃ­do filter_centrais() por filter_centrais_mongo()"
            
            else:
                return FixResult(
                    success=False,
                    error_pattern=error,
                    fix_applied="",
                    backup_path=backup_path,
                    validation_passed=False,
                    message="CorreÃ§Ã£o nÃ£o implementada para este tipo de erro de atributo"
                )
            
            # Salvar arquivo corrigido
            with open(error.file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Validar correÃ§Ã£o
            validation_passed = self.validate_fix(error.file_path)
            
            return FixResult(
                success=True,
                error_pattern=error,
                fix_applied=fix_description,
                backup_path=backup_path,
                validation_passed=validation_passed,
                message="CorreÃ§Ã£o aplicada com sucesso"
            )
            
        except Exception as e:
            return FixResult(
                success=False,
                error_pattern=error,
                fix_applied="",
                backup_path=backup_path,
                validation_passed=False,
                message=f"Erro ao aplicar correÃ§Ã£o: {e}"
            )
    
    def validate_fix(self, file_path: str) -> bool:
        """Valida se a correÃ§Ã£o nÃ£o introduziu novos erros"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Verificar sintaxe
            ast.parse(content)
            return True
            
        except SyntaxError:
            return False
        except Exception:
            return False
    
    def scan_project_for_errors(self) -> List[ErrorPattern]:
        """Escaneia todo o projeto em busca de erros"""
        all_errors = []
        
        # Arquivos Python para analisar
        python_files = []
        for root, dirs, files in os.walk(self.project_root):
            # Ignorar diretÃ³rios especÃ­ficos
            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', 'venv', 'env', 'backups']]
            
            for file in files:
                if file.endswith('.py'):
                    python_files.append(os.path.join(root, file))
        
        # Analisar cada arquivo
        for file_path in python_files:
            errors = self.analyze_file_for_errors(file_path)
            all_errors.extend(errors)
        
        return all_errors
    
    def apply_fixes(self, errors: List[ErrorPattern]) -> List[FixResult]:
        """Aplica correÃ§Ãµes para uma lista de erros"""
        results = []
        
        for error in errors:
            print(f"Corrigindo: {error.description}")
            
            if error.error_type == ErrorType.IMPORT_ERROR:
                result = self.fix_import_error(error)
            elif error.error_type == ErrorType.ATTRIBUTE_ERROR:
                result = self.fix_attribute_error(error)
            else:
                result = FixResult(
                    success=False,
                    error_pattern=error,
                    fix_applied="",
                    backup_path=None,
                    validation_passed=False,
                    message=f"CorreÃ§Ã£o nÃ£o implementada para {error.error_type.value}"
                )
            
            results.append(result)
            
            if result.success:
                print(f"âœ… {result.fix_applied}")
            else:
                print(f"âŒ {result.message}")
        
        return results
    
    def generate_fix_report(self, results: List[FixResult]) -> str:
        """Gera relatÃ³rio das correÃ§Ãµes aplicadas"""
        total = len(results)
        successful = len([r for r in results if r.success])
        failed = total - successful
        
        report = f"""
=== RELATÃ“RIO DE CORREÃ‡Ã•ES AUTOMÃTICAS ===
Data: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

RESUMO:
- Total de correÃ§Ãµes tentadas: {total}
- Bem-sucedidas: {successful}
- Falharam: {failed}
- Taxa de sucesso: {(successful/total*100):.1f}%

DETALHES:
"""
        
        for result in results:
            status = "âœ…" if result.success else "âŒ"
            report += f"{status} {result.error_pattern.description}\n"
            
            if result.success:
                report += f"   ğŸ”§ CorreÃ§Ã£o: {result.fix_applied}\n"
                report += f"   ğŸ“ Backup: {result.backup_path}\n"
                report += f"   âœ“ ValidaÃ§Ã£o: {'Passou' if result.validation_passed else 'Falhou'}\n"
            else:
                report += f"   âŒ Erro: {result.message}\n"
            
            if result.error_pattern.file_path:
                report += f"   ğŸ“„ Arquivo: {result.error_pattern.file_path}\n"
                if result.error_pattern.line_number:
                    report += f"   ğŸ“ Linha: {result.error_pattern.line_number}\n"
            
            report += "\n"
        
        return report
    
    def run_auto_fix(self) -> List[FixResult]:
        """Executa o processo completo de correÃ§Ã£o automÃ¡tica"""
        print("ğŸ” Escaneando projeto em busca de erros...")
        errors = self.scan_project_for_errors()
        
        if not errors:
            print("âœ… Nenhum erro detectado!")
            return []
        
        print(f"ğŸš¨ {len(errors)} erro(s) detectado(s)")
        
        print("ğŸ”§ Aplicando correÃ§Ãµes automÃ¡ticas...")
        results = self.apply_fixes(errors)
        
        # Gerar relatÃ³rio
        report = self.generate_fix_report(results)
        
        # Salvar relatÃ³rio
        report_file = f"fix_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report)
        
        print(report)
        print(f"ğŸ“„ RelatÃ³rio salvo em: {report_file}")
        
        return results

def main():
    """FunÃ§Ã£o principal"""
    print("ğŸ› ï¸ Sistema de CorreÃ§Ã£o AutomÃ¡tica - Almox SMS")
    print("=" * 60)
    
    fixer = AutoFixer()
    results = fixer.run_auto_fix()
    
    successful_fixes = len([r for r in results if r.success])
    if successful_fixes > 0:
        print(f"\nğŸ‰ {successful_fixes} correÃ§Ã£o(Ãµes) aplicada(s) com sucesso!")
    else:
        print("\nâœ… Nenhuma correÃ§Ã£o foi necessÃ¡ria ou possÃ­vel.")

if __name__ == "__main__":
    main()